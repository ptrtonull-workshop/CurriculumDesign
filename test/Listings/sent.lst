C51 COMPILER V9.54   SENT                                                                  05/12/2019 13:38:32 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE SENT
OBJECT MODULE PLACED IN .\Objects\sent.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE sent.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\sent
                    -.lst) TABS(2) OBJECT(.\Objects\sent.obj)

line level    source

   1          // Define SPI pins
   2          #include <reg51.h>
   3          
   4          #define uchar unsigned char
   5          
   6          /***************************************************/
   7          #define TX_ADR_WIDTH   5  // 5×Ö½Ú¿í¶ÈµÄ·¢ËÍ/½ÓÊÕµØÖ·
   8          #define TX_PLOAD_WIDTH 4  // Êý¾ÝÍ¨µÀÓÐÐ§Êý¾Ý¿í¶È
   9          sbit LED = P2^1;
  10          sbit KEY1 = P3^1;
  11          sbit KEY2 = P3^2;
  12          
  13          uchar code TX_ADDRESS[TX_ADR_WIDTH] = {0x34,0x43,0x10,0x10,0x01};  // ¶¨ÒåÒ»¸ö¾²Ì¬·¢ËÍµØÖ·
  14          uchar RX_BUF[TX_PLOAD_WIDTH];
  15          uchar TX_BUF[TX_PLOAD_WIDTH];
  16          uchar flag;
  17          uchar DATA = 0x01;
  18          uchar bdata sta;
  19          sbit  RX_DR     = sta^6;
  20          sbit  TX_DS     = sta^5;
  21          sbit  MAX_RT = sta^4;
  22          
  23          sbit CE =  P1^5;
  24          sbit CSN=  P1^4;
  25          sbit SCK=  P1^3;
  26          sbit MOSI= P1^2;
  27          sbit MISO= P1^1;
  28          sbit IRQ = P1^0;
  29          
  30          // SPI(nRF24L01) commands
  31          #define READ_REG    0x00  // Define read command to register
  32          #define WRITE_REG   0x20  // Define write command to register
  33          #define RD_RX_PLOAD 0x61  // Define RX payload register address
  34          #define WR_TX_PLOAD 0xA0  // Define TX payload register address
  35          #define FLUSH_TX    0xE1  // Define flush TX register command
  36          #define FLUSH_RX    0xE2  // Define flush RX register command
  37          #define REUSE_TX_PL 0xE3  // Define reuse TX payload register command
  38          #define NOP         0xFF  // Define No Operation, might be used to read status register
  39          
  40          // SPI(nRF24L01) registers(addresses)
  41          #define CONFIG      0x00  // 'Config' register address
  42          #define EN_AA       0x01  // 'Enable Auto Acknowledgment' register address
  43          #define EN_RXADDR   0x02  // 'Enabled RX addresses' register address
  44          #define SETUP_AW    0x03  // 'Setup address width' register address
  45          #define SETUP_RETR  0x04  // 'Setup Auto. Retrans' register address
  46          #define RF_CH       0x05  // 'RF channel' register address
  47          #define RF_SETUP    0x06  // 'RF setup' register address
  48          #define STATUS      0x07  // 'Status' register address
  49          #define OBSERVE_TX  0x08  // 'Observe TX' register address
  50          #define CD          0x09  // 'Carrier Detect' register address
  51          #define RX_ADDR_P0  0x0A  // 'RX address pipe0' register address
  52          #define RX_ADDR_P1  0x0B  // 'RX address pipe1' register address
  53          #define RX_ADDR_P2  0x0C  // 'RX address pipe2' register address
  54          #define RX_ADDR_P3  0x0D  // 'RX address pipe3' register address
C51 COMPILER V9.54   SENT                                                                  05/12/2019 13:38:32 PAGE 2   

  55          #define RX_ADDR_P4  0x0E  // 'RX address pipe4' register address
  56          #define RX_ADDR_P5  0x0F  // 'RX address pipe5' register address
  57          #define TX_ADDR     0x10  // 'TX address' register address
  58          #define RX_PW_P0    0x11  // 'RX payload width, pipe0' register address
  59          #define RX_PW_P1    0x12  // 'RX payload width, pipe1' register address
  60          #define RX_PW_P2    0x13  // 'RX payload width, pipe2' register address
  61          #define RX_PW_P3    0x14  // 'RX payload width, pipe3' register address
  62          #define RX_PW_P4    0x15  // 'RX payload width, pipe4' register address
  63          #define RX_PW_P5    0x16  // 'RX payload width, pipe5' register address
  64          #define FIFO_STATUS 0x17  // 'FIFO Status Register' register address
  65          
  66          void blink(char i);
  67          
  68          /**************************************************
  69          º¯Êý: init_io()
  70          
  71          ÃèÊö:
  72              ³õÊ¼»¯IO
  73          /**************************************************/
  74          void init_io(void)
  75          {
  76   1          CE  = 0;        // ´ý»ú
  77   1          CSN = 1;        // SPI½ûÖ¹
  78   1          SCK = 0;        // SPIÊ±ÖÓÖÃµÍ
  79   1          IRQ = 1;        // ÖÐ¶Ï¸´Î»
  80   1          LED = 1;        // ¹Ø±ÕÖ¸Ê¾µÆ
  81   1      }
  82          /**************************************************/
  83          
  84          /**************************************************
  85          º¯Êý£ºdelay_ms()
  86          
  87          ÃèÊö£º
  88              ÑÓ³ÙxºÁÃë
  89          /**************************************************/
  90          void delay_ms(uchar x)
  91          {
  92   1          uchar i, j;
  93   1          i = 0;
  94   1          for(i=0; i<x; i++)
  95   1          {
  96   2             j = 250;
  97   2             while(--j);
  98   2             j = 250;
  99   2             while(--j);
 100   2          }
 101   1      }
 102          /**************************************************/
 103          
 104          /**************************************************
 105          º¯Êý£ºSPI_RW()
 106          
 107          ÃèÊö£º
 108              ¸ù¾ÝSPIÐ­Òé£¬Ð´Ò»×Ö½ÚÊý¾Ýµ½nRF24L01£¬Í¬Ê±´ÓnRF24L01
 109              ¶Á³öÒ»×Ö½Ú
 110          /**************************************************/
 111          uchar SPI_RW(uchar byte)
 112          {
 113   1          uchar i;
 114   1             for(i=0; i<8; i++)          // Ñ­»·8´Î
 115   1             {
 116   2                 MOSI = (byte & 0x80);   // byte×î¸ßÎ»Êä³öµ½MOSI
C51 COMPILER V9.54   SENT                                                                  05/12/2019 13:38:32 PAGE 3   

 117   2                 byte <<= 1;             // µÍÒ»Î»ÒÆÎ»µ½×î¸ßÎ»
 118   2                 SCK = 1;                // À­¸ßSCK£¬nRF24L01´ÓMOSI¶ÁÈë1Î»Êý¾Ý£¬Í¬Ê±´ÓMISOÊä³ö1Î»Êý¾Ý
 119   2                 byte |= MISO;           // ¶ÁMISOµ½byte×îµÍÎ»
 120   2                 SCK = 0;                // SCKÖÃµÍ
 121   2             }
 122   1          return(byte);               // ·µ»Ø¶Á³öµÄÒ»×Ö½Ú
 123   1      }
 124          /**************************************************/
 125          
 126          /**************************************************
 127          º¯Êý£ºSPI_RW_Reg()
 128          
 129          ÃèÊö£º
 130              Ð´Êý¾Ývalueµ½reg¼Ä´æÆ÷
 131          /**************************************************/
 132          uchar SPI_RW_Reg(uchar reg, uchar value)
 133          {
 134   1          uchar status;
 135   1            CSN = 0;                   // CSNÖÃµÍ£¬¿ªÊ¼´«ÊäÊý¾Ý
 136   1            status = SPI_RW(reg);      // Ñ¡Ôñ¼Ä´æÆ÷£¬Í¬Ê±·µ»Ø×´Ì¬×Ö
 137   1            SPI_RW(value);             // È»ºóÐ´Êý¾Ýµ½¸Ã¼Ä´æÆ÷
 138   1            CSN = 1;                   // CSNÀ­¸ß£¬½áÊøÊý¾Ý´«Êä
 139   1            return(status);            // ·µ»Ø×´Ì¬¼Ä´æÆ÷
 140   1      }
 141          /**************************************************/
 142          
 143          /**************************************************
 144          º¯Êý£ºSPI_Read()
 145          
 146          ÃèÊö£º
 147              ´Óreg¼Ä´æÆ÷¶ÁÒ»×Ö½Ú
 148          /**************************************************/
 149          uchar SPI_Read(uchar reg)
 150          {
 151   1          uchar reg_val;
 152   1            CSN = 0;                    // CSNÖÃµÍ£¬¿ªÊ¼´«ÊäÊý¾Ý
 153   1            SPI_RW(reg);                // Ñ¡Ôñ¼Ä´æÆ÷
 154   1            reg_val = SPI_RW(0);        // È»ºó´Ó¸Ã¼Ä´æÆ÷¶ÁÊý¾Ý
 155   1            CSN = 1;                    // CSNÀ­¸ß£¬½áÊøÊý¾Ý´«Êä
 156   1            return(reg_val);            // ·µ»Ø¼Ä´æÆ÷Êý¾Ý
 157   1      }
 158          /**************************************************/
 159          
 160          /**************************************************
 161          º¯Êý£ºSPI_Read_Buf()
 162          
 163          ÃèÊö£º
 164              ´Óreg¼Ä´æÆ÷¶Á³öbytes¸ö×Ö½Ú£¬Í¨³£ÓÃÀ´¶ÁÈ¡½ÓÊÕÍ¨µÀ
 165              Êý¾Ý»ò½ÓÊÕ/·¢ËÍµØÖ·
 166          /**************************************************/
 167          uchar SPI_Read_Buf(uchar reg, uchar * pBuf, uchar bytes)
 168          {
 169   1          uchar status, i;
 170   1            CSN = 0;                    // CSNÖÃµÍ£¬¿ªÊ¼´«ÊäÊý¾Ý
 171   1            status = SPI_RW(reg);       // Ñ¡Ôñ¼Ä´æÆ÷£¬Í¬Ê±·µ»Ø×´Ì¬×Ö
 172   1            for(i=0; i<bytes; i++)
 173   1              pBuf[i] = SPI_RW(0);    // Öð¸ö×Ö½Ú´ÓnRF24L01¶Á³ö
 174   1            CSN = 1;                    // CSNÀ­¸ß£¬½áÊøÊý¾Ý´«Êä
 175   1            return(status);             // ·µ»Ø×´Ì¬¼Ä´æÆ÷
 176   1      }
 177          /**************************************************/
 178          
C51 COMPILER V9.54   SENT                                                                  05/12/2019 13:38:32 PAGE 4   

 179          /**************************************************
 180          º¯Êý£ºSPI_Write_Buf()
 181          
 182          ÃèÊö£º
 183              °ÑpBuf»º´æÖÐµÄÊý¾ÝÐ´Èëµ½nRF24L01£¬Í¨³£ÓÃÀ´Ð´Èë·¢
 184              ÉäÍ¨µÀÊý¾Ý»ò½ÓÊÕ/·¢ËÍµØÖ·
 185          /**************************************************/
 186          uchar SPI_Write_Buf(uchar reg, uchar * pBuf, uchar bytes)
 187          {
 188   1          uchar status, i;
 189   1            CSN = 0;                    // CSNÖÃµÍ£¬¿ªÊ¼´«ÊäÊý¾Ý
 190   1            status = SPI_RW(reg);       // Ñ¡Ôñ¼Ä´æÆ÷£¬Í¬Ê±·µ»Ø×´Ì¬×Ö
 191   1            for(i=0; i<bytes; i++)
 192   1              SPI_RW(pBuf[i]);        // Öð¸ö×Ö½ÚÐ´ÈënRF24L01
 193   1            CSN = 1;                    // CSNÀ­¸ß£¬½áÊøÊý¾Ý´«Êä
 194   1            return(status);             // ·µ»Ø×´Ì¬¼Ä´æÆ÷
 195   1      }
 196          /**************************************************/
 197          
 198          /**************************************************
 199          º¯Êý£ºRX_Mode()
 200          
 201          ÃèÊö£º
 202              Õâ¸öº¯ÊýÉèÖÃnRF24L01Îª½ÓÊÕÄ£Ê½£¬µÈ´ý½ÓÊÕ·¢ËÍÉè±¸µÄÊý¾Ý°ü
 203          /**************************************************/
 204          void RX_Mode(void)
 205          {
 206   1          CE = 0;
 207   1            SPI_Write_Buf(WRITE_REG + RX_ADDR_P0, TX_ADDRESS, TX_ADR_WIDTH);  // ½ÓÊÕÉè±¸½ÓÊÕÍ¨µÀ0Ê¹ÓÃºÍ·¢ËÍÉè±¸
             -ÏàÍ¬µÄ·¢ËÍµØÖ·
 208   1            SPI_RW_Reg(WRITE_REG + EN_AA, 0x01);               // Ê¹ÄÜ½ÓÊÕÍ¨µÀ0×Ô¶¯Ó¦´ð
 209   1            SPI_RW_Reg(WRITE_REG + EN_RXADDR, 0x01);           // Ê¹ÄÜ½ÓÊÕÍ¨µÀ0
 210   1            SPI_RW_Reg(WRITE_REG + RF_CH, 40);                 // Ñ¡ÔñÉäÆµÍ¨µÀ0x40
 211   1            SPI_RW_Reg(WRITE_REG + RX_PW_P0, TX_PLOAD_WIDTH);  // ½ÓÊÕÍ¨µÀ0Ñ¡ÔñºÍ·¢ËÍÍ¨µÀÏàÍ¬ÓÐÐ§Êý¾Ý¿í¶È
 212   1            SPI_RW_Reg(WRITE_REG + RF_SETUP, 0x07);            // Êý¾Ý´«ÊäÂÊ1Mbps£¬·¢Éä¹¦ÂÊ0dBm£¬µÍÔëÉù·Å´óÆ÷ÔöÒ
             -æ
 213   1            SPI_RW_Reg(WRITE_REG + CONFIG, 0x0f);              // CRCÊ¹ÄÜ£¬16Î»CRCÐ£Ñé£¬ÉÏµç£¬½ÓÊÕÄ£Ê½
 214   1          delay_ms(150);
 215   1            CE = 1;                                            // À­¸ßCEÆô¶¯½ÓÊÕÉè±¸
 216   1      }
 217          /**************************************************/
 218          
 219          /**************************************************
 220          º¯Êý£ºTX_Mode()
 221          
 222          ÃèÊö£º
 223              Õâ¸öº¯ÊýÉèÖÃnRF24L01Îª·¢ËÍÄ£Ê½£¬£¨CE=1³ÖÐøÖÁÉÙ10us£©£¬
 224              130usºóÆô¶¯·¢Éä£¬Êý¾Ý·¢ËÍ½áÊøºó£¬·¢ËÍÄ£¿é×Ô¶¯×ªÈë½ÓÊÕ
 225              Ä£Ê½µÈ´ýÓ¦´ðÐÅºÅ¡£
 226          /**************************************************/
 227          void TX_Mode(uchar * BUF)
 228          {
 229   1          CE = 0;
 230   1            SPI_Write_Buf(WRITE_REG + TX_ADDR, TX_ADDRESS, TX_ADR_WIDTH);     // Ð´Èë·¢ËÍµØÖ·
 231   1            SPI_Write_Buf(WRITE_REG + RX_ADDR_P0, TX_ADDRESS, TX_ADR_WIDTH);  // ÎªÁËÓ¦´ð½ÓÊÕÉè±¸£¬½ÓÊÕÍ¨µÀ0µØÖ·
             -ºÍ·¢ËÍµØÖ·ÏàÍ¬
 232   1            SPI_Write_Buf(WR_TX_PLOAD, BUF, TX_PLOAD_WIDTH);                  // Ð´Êý¾Ý°üµ½TX FIFO
 233   1            SPI_RW_Reg(WRITE_REG + EN_AA, 0x01);       // Ê¹ÄÜ½ÓÊÕÍ¨µÀ0×Ô¶¯Ó¦´ð
 234   1            SPI_RW_Reg(WRITE_REG + EN_RXADDR, 0x01);   // Ê¹ÄÜ½ÓÊÕÍ¨µÀ0
 235   1            SPI_RW_Reg(WRITE_REG + SETUP_RETR, 0x0a);  // ×Ô¶¯ÖØ·¢ÑÓÊ±µÈ´ý250us+86us£¬×Ô¶¯ÖØ·¢10´Î
 236   1            SPI_RW_Reg(WRITE_REG + RF_CH, 40);         // Ñ¡ÔñÉäÆµÍ¨µÀ0x40
 237   1            SPI_RW_Reg(WRITE_REG + RF_SETUP, 0x07);    // Êý¾Ý´«ÊäÂÊ1Mbps£¬·¢Éä¹¦ÂÊ0dBm£¬µÍÔëÉù·Å´óÆ÷ÔöÒæ
C51 COMPILER V9.54   SENT                                                                  05/12/2019 13:38:32 PAGE 5   

 238   1            SPI_RW_Reg(WRITE_REG + CONFIG, 0x0e);      // CRCÊ¹ÄÜ£¬16Î»CRCÐ£Ñé£¬ÉÏµç
 239   1          delay_ms(150);
 240   1          CE = 1;
 241   1      }
 242          /**************************************************/
 243          
 244          /**************************************************
 245          º¯Êý£ºCheck_ACK()
 246          
 247          ÃèÊö£º
 248              ¼ì²é½ÓÊÕÉè±¸ÓÐÎÞ½ÓÊÕµ½Êý¾Ý°ü£¬Éè¶¨Ã»ÓÐÊÕµ½Ó¦´ðÐÅ
 249              ºÅÊÇ·ñÖØ·¢
 250          /**************************************************/
 251          uchar Check_ACK(bit clear)
 252          {
 253   1          delay_ms(200);
 254   1          while(IRQ);
 255   1          sta = SPI_RW(NOP);                    // ·µ»Ø×´Ì¬¼Ä´æÆ÷
 256   1          if(TX_DS)
 257   1          {
 258   2              blink(3);
 259   2          }
 260   1          //blink(5);
 261   1          if(MAX_RT)
 262   1              if(clear)                         // ÊÇ·ñÇå³ýTX FIFO£¬Ã»ÓÐÇå³ýÔÚ¸´Î»MAX_RTÖÐ¶Ï±êÖ¾ºóÖØ·¢
 263   1                  SPI_RW(FLUSH_TX);
 264   1          SPI_RW_Reg(WRITE_REG + STATUS, sta);  // Çå³ýTX_DS»òMAX_RTÖÐ¶Ï±êÖ¾
 265   1          IRQ = 1;
 266   1          if(TX_DS)
 267   1              return(0x00);
 268   1          else
 269   1              return(0xff);
 270   1      }
 271          /**************************************************/
 272          
 273          /**************************************************
 274          º¯Êý£ºCheckButtons()
 275          
 276          ÃèÊö£º
 277              ¼ì²é°´¼üÊÇ·ñ°´ÏÂ£¬°´ÏÂÔò·¢ËÍÒ»×Ö½ÚÊý¾Ý
 278          /**************************************************/
 279          void CheckButtons()
 280          {
 281   1          if(KEY1 == 0)
 282   1          {
 283   2              delay_ms(20);
 284   2              if(KEY1 == 0)
 285   2              {
 286   3                  TX_BUF[0] = 1;          // Êý¾ÝËÍµ½»º´æ
 287   3                  //TX_BUF[0] = 0xff;          // Êý¾ÝËÍµ½»º´æ
 288   3                  TX_Mode(TX_BUF);            // °ÑnRF24L01ÉèÖÃÎª·¢ËÍÄ£Ê½²¢·¢ËÍÊý¾Ý            
 289   3                  //LED = ~DATA;                // Êý¾ÝËÍµ½LEDÏÔÊ¾
 290   3                  Check_ACK(0);               // µÈ´ý·¢ËÍÍê±Ï£¬Çå³ýTX FIFO
 291   3                  delay_ms(250);
 292   3                  delay_ms(250);
 293   3              }
 294   2          }
 295   1      
 296   1          if(KEY2 == 0)
 297   1          {
 298   2              delay_ms(20);
 299   2              if(KEY2 == 0)
C51 COMPILER V9.54   SENT                                                                  05/12/2019 13:38:32 PAGE 6   

 300   2              {
 301   3                  TX_BUF[0] = 2;          // Êý¾ÝËÍµ½»º´æ
 302   3                  //TX_BUF[0] = 0xff;          // Êý¾ÝËÍµ½»º´æ
 303   3                  TX_Mode(TX_BUF);            // °ÑnRF24L01ÉèÖÃÎª·¢ËÍÄ£Ê½²¢·¢ËÍÊý¾Ý            
 304   3                  //LED = ~DATA;                // Êý¾ÝËÍµ½LEDÏÔÊ¾
 305   3                  Check_ACK(0);               // µÈ´ý·¢ËÍÍê±Ï£¬Çå³ýTX FIFO
 306   3                  delay_ms(250);
 307   3                  delay_ms(250);
 308   3              }
 309   2          }
 310   1      
 311   1      
 312   1      }
 313          /**************************************************/
 314          
 315          void blink(char i)
 316          {
 317   1          while(i--)
 318   1          {
 319   2              LED = 1;
 320   2              delay_ms(500);
 321   2              LED = 0;
 322   2              delay_ms(500);
 323   2          }
 324   1      
 325   1      }
 326          
 327          /**************************************************
 328          º¯Êý£ºmain()
 329          
 330          ÃèÊö£º
 331              Ö÷º¯Êý
 332          /**************************************************/
 333          void main(void)
 334          {
 335   1          init_io();                      // ³õÊ¼»¯IO
 336   1      
 337   1          while(1)
 338   1          {
 339   2              CheckButtons();           // °´¼üÉ¨Ãè
 340   2          }
 341   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    466    ----
   CONSTANT SIZE    =      5    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     11      13
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
